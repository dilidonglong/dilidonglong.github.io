---
title: 磁盘分区
date: 2019-04-30 23:32:07
categories: linux
tags:
---

# 磁盘分区

## 1.磁盘分区

**磁盘**包含：碟片（细分为**扇区**和**磁道**）、机械手臂、磁头、主轴马达

**扇区**大小分为**512B**和**4KB**

<!--more-->

### 1.1第一个扇区（MBR）

**磁盘第一个扇区**存放**启动引导程序**和**磁盘分区表**（格式分为**MBR**[Windows支持]和**GPT**）

| MBR（master boot record） | 启动引导程序 | 磁盘分区表 |
| :-----------------------: | :----------: | :--------: |
|  主引导记录容量（512B）   |     446B     |    64B     |

MBR分区表的限制：

> 1. 分区最多到2TB
> 2. MBR仅占一个扇区，被破坏后，很难恢复甚至无法恢复
> 3. MBR内的启动引导程序只有446B，无法存储较多的程序代码



#### 1.1.1MBR**磁盘分区表**

> 1. 分区表占64B，给磁盘划分分区，其实就是对这个分区表做设置
> 2. 分区表默认最多把一个磁盘分为4个分区
> 3. 分区分为**主要分区**和**扩展分区**
> 4. 要写入数据到磁盘时，会参考这个分区表



#### 1.1.2MBR扩展分区

由于磁盘分区表的限制，最多给磁盘划分出4个分区。那么我们可以利用额外的扇区来记录更多的分区信息。

在**扩展分区**的某个地方来记录在扩展分区里面的其他**逻辑分区**信息

> 1. 扩展分区最多一个
> 2. 逻辑分区是在扩展分区里面划分出来的
> 3. 能格式化的是主要分区和逻辑分区，扩展分区不能被格式化
> 4. 逻辑分区能划分多少个，依据不同操作系统来定



------

### 1.2GPT磁盘分区表

现在的磁盘越来越大，如果使用磁盘阵列等技术，那么在Linux平台下看到的磁盘大小可能就有几十个TB。使用MBR格式，要划分分区时，就要2TB/2TB地划分下去。这就可能划分出好几十个分区，为了解决这个问题，就有了GPT这种磁盘分区的格式。

以前扇区大小为512B，现在已经有了4KB的扇区。为兼容所有磁盘，会使用到**逻辑区块地址LBA**（logical block address），LBA默认是512B。在GPT这种格式下，将磁盘的所有区块使用LBA来规划。`可以理解为，如果一个扇区的容量是512B，然后LBA默认是512B的话，那么一个扇区就是一个区块。如果一个扇区容量是4KB=8*512B，那么一个区块地址就是1/8扇区`

**第一个LBA**称为**LBA0**

**MBR使用第一个扇区来记录，而GPT使用了前34个LBA区块来记录。**由于MBR只有一个区块，破坏就难以恢复。不同于MBR，**GPT中会用磁盘的最后34个LBA做备份**。



#### 1.2.1LBA0（MBR兼容区块）

|     LBA0      | 引导启动程序 |        特殊标志符        |
| :-----------: | :----------: | :----------------------: |
| 逻辑区块地址0 |     446B     | 64B，表示磁盘使用GPT格式 |

 

#### 1.2.2LBA1（GPT表头记录）

记录磁盘分区表本身的位置和大小，同时记录了备份的GPT分区位置。



#### 1.2.3LBA2-33（实际记录分区信息处）

**从LBA2区块开始，每个LBA可以记录4组分区记录**。所以一个磁盘在默认情况下，可以划分4*32=128个分区。

在MBR中，分区表的大小是64B，而在GPT中是512B。

一个区块记录4组分区，所以在GPT的分区表中，一组分区记录可以占512/4=128B的空间大小。

在这128B的空间中使用64bit来记录开始和结束的扇区号码

每个分区的最大容量限制就是：$2^{64}*512B=8ZB$





## 2.启动程序

CMOS是一个嵌入在主板的存储器，存储着各项硬件参数

BIOS是一个写入到主板的固件（**固件是**写入到硬件上的一个**软件程序**）

> 1. 计算机系统在启动时，主动执行的第一个程序就是BIOS
> 2. BIOS执行后，会分析计算机里面的存储设备。比如发现了硬盘，BIOS就去找那个能启动的硬盘
> 3. 找到该硬盘，就读取第一个扇区的MBR位置，找到那个446B的启动引导程序
>
> 以上BIOS的任务完成，接下来就是启动引导程序干活了
>
> 4. 启动引导程序的目的是加载内核文件
>
> 加载完后，启动引导程序的活也干完了
>
> 5. 之后就是内核文件开始工作，再之后就是把任务都交给我们熟悉的操作系统完成

